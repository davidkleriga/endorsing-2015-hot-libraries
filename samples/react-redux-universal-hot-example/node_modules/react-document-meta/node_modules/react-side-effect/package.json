{
  "name": "react-side-effect",
  "version": "1.0.1",
  "description": "Create components whose prop changes map to a global side effect",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/gaearon/react-side-effect.git"
  },
  "keywords": [
    "react",
    "component",
    "side",
    "effect"
  ],
  "author": {
    "name": "Dan Abramov",
    "email": "dan.abramov@me.com",
    "url": "http://github.com/gaearon"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/gaearon/react-side-effect/issues"
  },
  "homepage": "https://github.com/gaearon/react-side-effect",
  "dependencies": {
    "fbjs": "0.1.0-alpha.10"
  },
  "readme": "# React Side Effect\n\nCreate components whose prop changes map to a global side effect.\n\n## Installation\n\n```\nnpm install --save react-side-effect\n```\n\nNote: React Side Effect requires React 0.13+.\n\n## Use Cases\n\n* Setting `document.style.overflow` or background color depending on current screen;\n* Firing Flux actions using declarative API depending on current screen;\n* Some crazy stuff I haven't thought about.\n\n## How's That Different from `componentDidUpdate`?\n\nIt gathers current props across *the whole tree* before passing them to side effect. For example, this allows you to create `<BodyStyle style>` component like this:\n\n```js\n// RootComponent.js\nreturn (\n  <BodyStyle style={{ backgroundColor: 'red' }}>\n    {this.state.something ? <SomeComponent /> : <OtherComponent />}\n  </BodyStyle>\n);\n\n// SomeComponent.js\nreturn (\n  <BodyStyle style={{ backgroundColor: this.state.color }}>\n    <div>Choose color: <input valueLink={this.linkState('color')} /></div>\n  </BodyStyle>\n);\n```\n\nand let the effect handler merge `style` from different level of nesting with innermost winning:\n\n```js\nimport { Component, Children, PropTypes } from 'react';\nimport withSideEffect from 'react-side-effect';\n\nclass BodyStyle extends Component {\n  render() {\n    return Children.only(this.props.children);\n  }\n}\n\nBodyStyle.propTypes = {\n  style: PropTypes.object.isRequired\n};\n\nfunction reducePropsToState(propsList) {\n  var style = {};\n  propsList.forEach(function (props) {\n    Object.assign(style, props.style);\n  });\n  return style;\n}\n\nfunction handleStateChangeOnClient(style) {\n  for (var key in style) {\n    document.style[key] = style[key];\n  }\n}\n\nexport default withSideEffect(\n  reducePropsToState,\n  handleStateChangeOnClient\n)(BodyStyle);\n```\n\nOn the server, you’ll be able to call `BodyStyle.peek()` to get the current state, and `BodyStyle.rewind()` to reset for each next request. The `handleStateChangeOnClient` will only be called on the client.\n\n## API\n\n#### `withSideEffect: (reducePropsToState, handleStateChangeOnClient, [mapStateOnServer]) -> ReactComponent -> ReactComponent`\n\nA [higher-order component](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750) that, when mounting, unmounting or receiving new props, calls `reducePropsToState` with `props` of **each mounted instance**. It is up to you to return some state aggregated from these props.\n\nOn the client, every time the returned component is (un)mounted or its props change, `reducePropsToState` will be called, and the recalculated state will be passed to `handleStateChangeOnClient` where you may use it to trigger a side effect.\n\nOn the server, `handleStateChangeOnClient` will not be called. You will still be able to call the static `rewind()` method on the returned component class to retrieve the current state after a `renderToString()` call. If you forget to call `rewind()` right after `renderToString()`, the internal instance stack will keep growing, resulting in a memory leak and incorrect information. You must call `rewind()` after every `renderToString()` call on the server.\n\nFor testing, you may use a static `peek()` method available on the returned component. It lets you get the current state without resetting the mounted instance stack. Don’t use it for anything other than testing.\n\n## Usage\n\nHere's how to implement [React Document Title](https://github.com/gaearon/react-document-title) (both client and server side) using React Side Effect:\n\n```js\nimport React, { Children, Component, PropTypes } from 'react';\nimport withSideEffect from 'react-side-effect';\n\nclass DocumentTitle extends Component {\n  render: function render() {\n    if (this.props.children) {\n      return Children.only(this.props.children);\n    } else {\n      return null;\n    }\n  }\n}\n\nDocumentTitle.propTypes = {\n  title: PropTypes.string.isRequired\n};\n\nfunction reducePropsToState(propsList) {\n  var innermostProps = propsList[propsList.length - 1];\n  if (innermostProps) {\n    return innermostProps.title;\n  }\n}\n\nfunction handleStateChangeOnClient(title) {\n  document.title = title || '';\n}\n\nexport default withSideEffect(\n  reducePropsToState,\n  handleStateChangeOnClient\n)(DocumentTitle);\n```\n",
  "readmeFilename": "README.md",
  "_id": "react-side-effect@1.0.1",
  "_shasum": "1534287422468d463da00f5ad441df8e13b5b26b",
  "_from": "react-side-effect@^1.0.1",
  "_resolved": "https://registry.npmjs.org/react-side-effect/-/react-side-effect-1.0.1.tgz"
}
