{
  "name": "redux-form",
  "version": "1.5.0",
  "description": "A higher order component decorator for forms using Redux and React",
  "main": "./lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/erikras/redux-form"
  },
  "scripts": {
    "build": "npm run build:lib && npm run build:umd && npm run build:umd:min",
    "build:lib": "babel src --out-dir lib",
    "build:umd": "webpack src/index.js dist/redux-form.js --config webpack.config.development.js",
    "build:umd:min": "webpack src/index.js dist/redux-form.min.js --config webpack.config.production.js",
    "clean": "rimraf dist lib",
    "lint": "eslint src",
    "prepublish": "npm run lint && npm run test && npm run clean && npm run build",
    "test": "mocha --compilers js:babel/register --recursive"
  },
  "keywords": [
    "react",
    "reactjs",
    "flux",
    "redux",
    "react-redux",
    "redux-form",
    "form",
    "decorator"
  ],
  "author": {
    "name": "Erik Rasmussen",
    "email": "rasmussenerik@gmail.com",
    "url": "http://github.com/erikras"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/erikras/redux-form/issues"
  },
  "homepage": "https://github.com/erikras/redux-form",
  "devDependencies": {
    "babel": "^5.8.21",
    "babel-core": "^5.8.22",
    "babel-eslint": "^4.0.10",
    "babel-loader": "5.3.2",
    "eslint": "^1.2.0",
    "eslint-config-airbnb": "0.0.7",
    "eslint-plugin-react": "^3.2.3",
    "expect": "^1.9.0",
    "mocha": "^2.3.0",
    "react": "^0.13.3",
    "rifraf": "^2.0.2",
    "rimraf": "^2.4.2",
    "webpack": "^1.10.5"
  },
  "dependencies": {
    "react-redux": "^1.0.0",
    "redux": "^1.0.0"
  },
  "npmName": "redux-form",
  "npmFileMap": [
    {
      "basePath": "/dist/",
      "files": [
        "*.js"
      ]
    }
  ],
  "readme": "#redux-form\n---\n[![NPM Version](https://img.shields.io/npm/v/redux-form.svg?style=flat)](https://www.npmjs.com/package/redux-form) \n[![NPM Downloads](https://img.shields.io/npm/dm/redux-form.svg?style=flat)](https://www.npmjs.com/package/redux-form)\n[![Build Status](https://img.shields.io/travis/erikras/redux-form/master.svg?style=flat)](https://travis-ci.org/erikras/redux-form)\n[![devDependency Status](https://david-dm.org/erikras/redux-form/dev-status.svg)](https://david-dm.org/erikras/redux-form#info=devDependencies)\n[![redux-form channel on slack](https://img.shields.io/badge/slack-redux--form%40reactiflux-blue.svg)](http://www.reactiflux.com)\n[![PayPal donate button](http://img.shields.io/paypal/donate.png?color=yellowgreen)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=3QQPTMLGV6GU2)\n\n`redux-form` works with [React Redux](https://github.com/gaearon/react-redux) to enable an html form in\n[React](https://github.com/facebook/react) to use [Redux](https://github.com/gaearon/redux) to store all of its state.\n\n## Table of Contents\n\n* [Installation](#installation)\n* [Release Notes](https://github.com/erikras/redux-form/releases)\n* [Benefits](#benefits) - Why use this library?\n  * [Unidirectional Data Flow](#unidirectonal-data-flow)\n  * [Redux Dev Tools](#redux-dev-tools)\n  * [Stateless Components](#stateless-components)\n* [Implementation Guide](#implementation-guide) <-------------- **Start here!**\n  * [A Simple Form Component](#a-simple-form-component)\n  * [ES7 Decorator Sugar](#es7-decorator-sugar) - :warning: Experimental! :warning:\n  * [Synchronous Validation](#synchronous-validation) - Client Side\n  * [Asynchronous Validation](#asynchronous-validation) - Server Side\n  * [Submitting Your Form](#submitting-your-form)\n  * [Responding to Other Actions](#responding-to-other-actions)\n  * [Normalizing Form Data](#normalizing-form-data)\n  * [Editing Multiple Records](#editing-multiple-records)\n  * [Calculating `props` from Form Data](#calculating-props-from-form-data)\n  * [Dynamic Forms](#dynamic-forms)\n  * [Advanced Usage](#advanced-usage)\n    * [Doing the `connect()`ing Yourself](#doing-the-connecting-yourself)\n      * [Binding Action Creators](#binding-action-creators)\n* [API](#api)\n  * [`connectReduxForm(config)`](#connectreduxformconfigobject)\n  * [`reduxForm(config)`](#reduxformconfigobject)\n  * [`reducer`](#reducer)\n  * [`reducer.plugin(Object<String, Function>)`](#reducerpluginobjectstring-function)\n  * [`reducer.normalize(Object<String, Function>)`](#reducerpluginobjectstring-function)\n  * [`props` passed into your decorated component](#props-passed-into-your-decorated-component) - props provided by \n  `redux-form`\n  * [`props` you can pass into your decorated component](#props-you-can-pass-into-your-decorated-component) - extra\n  functionality!\n  * [Action Creators](#action-creators) - Advanced\n* [Working Demo](#working-demo)\n\n---\n\n## Installation\n\n```\nnpm install --save redux-form\n```\n\n## Release Notes\n\nThis project follows [SemVer](http://semver.org) and each release is posted on the \n[Release Notes](https://github.com/erikras/redux-form/releases) page.\n\n## Benefits\n\nWhy would anyone want to do this, you ask? React a perfectly good way of keeping state in each component! The\nreasons are threefold.\n\n#### Unidirectional Data Flow\n\nFor the same reason that React and Flux is superior to Angular's bidirectional data binding. Tracking down bugs\nis much simpler when the data all flows through one dispatcher.\n\n#### Redux Dev Tools\n\nWhen used in conjunction with [Redux Dev Tools](https://github.com/gaearon/redux-devtools), you can fast forward\nand rewind through your form data entry to better find bugs.\n\n#### Stateless Components\n\nBy removing the state from your form components, you inherently make them easier to understand, test, and debug.\nThe React philosophy is to always try to use `props` instead of `state` when possible.\n\n## Implementation Guide\n\n__STEP 1:__ The first thing that you have to do is to give the `redux-form` reducer to Redux. You will only have to do \nthis\nonce, no matter how many form components your app uses.\n\n```javascript\nimport { createStore, combineReducers } from 'redux';\nimport { reducer as formReducer } from 'redux-form';\nconst reducers = {\n  // ... your other reducers here ...\n  form: formReducer           // <---- Mounted at 'form'. See note below.\n}\nconst reducer = combineReducers(reducers);\nconst store = createStore(reducer);\n```\n\n*NOTE* â€“ If you are not [doing the `connect()`ing yourself](#doing-the-connecting-yourself) (and it is recommended that \nyou do not, unless you have an advanced use case that requires it), _you **must** mount the reducer at `form`_.\n\n__STEP 2:__ Wrap your form component with `connectReduxForm()`.  `connectReduxForm()` wraps your form component in a \nHigher Order Component that connects to the Redux store and provides functions, as props to your component, for your \nform elements to use for sending `onChange` and `onBlur` events, as well as a function to handle synchronous\nvalidation `onSubmit`. Let's look at a simple example.\n\n### A Simple Form Component\n\nYou will need to wrap your form component with `redux-form`'s `connectReduxForm()` function.\n\n> ___IMPORTANT:___ _If you are using `redux-form` with `react-native`, you will need to \n[use `reduxForm()` instead of `connectReduxForm()`](#doing-the-connecting-yourself), at least until React 0.14\nis released._\n\n```javascript\nimport React, {Component, PropTypes} from 'react';\nimport {connectReduxForm} from 'redux-form';\nimport validateContact from './validateContact';\n\nclass ContactForm extends Component {\n  static propTypes = {\n    fields: PropTypes.object.isRequired,\n    handleSubmit: PropTypes.func.isRequired\n  }\n  \n  render() {\n    const { fields: {name, address, phone}, handleSubmit } = this.props;\n    return (\n      <form onSubmit={handleSubmit}>\n        <label>Name</label>\n        <input type=\"text\" {...name}/>     // will pass value, onBlur and onChange\n        {name.error && name.touched ? <div>{name.error}</div>}\n        \n        <label>Address</label>\n        <input type=\"text\" {...address}/>  // will pass value, onBlur and onChange\n        {address.error && address.touched ? <div>{address.error}</div>}\n        \n        <label>Phone</label>\n        <input type=\"text\" {...phone}/>    // will pass value, onBlur and onChange\n        {phone.error && phone.touched ? <div>{phone.error}</div>}\n        \n        <button onClick={handleSubmit}>Submit</button>\n      </form>\n    );\n  }\n}\n\n// apply connectReduxForm() and include synchronous validation\nContactForm = connectReduxForm({\n  form: 'contact',                      // the name of your form and the key to\n                                        // where your form's state will be mounted\n  fields: ['name', 'address', 'phone'], // a list of all your fields in your form\n  validate: validateContact             // a synchronous validation function\n})(ContactForm);\n\n// export the wrapped component\nexport default ContactForm;\n```\n\nNotice that we're just using vanilla `<input>` elements there is no state in the `ContactForm` component.\n`handleSubmit` will call the function passed into `ContactForm`'s [`onSubmit` prop](#onsubmit-function-optional), _if \nand only if_ the synchronous validation passes. See [Submitting Your Form](#submitting-your-form).\n\n### ES7 Decorator Sugar\n\nUsing [ES7 decorator proposal](https://github.com/wycats/javascript-decorators), the example above\ncould be written as:\n\n```javascript\n@connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact\n})\nexport default class ContactForm extends Component {\n```\n\nMuch nicer, don't you think?\n\nYou can enable it with [Babel Stage 1](http://babeljs.io/docs/usage/experimental/). Note that decorators\nare experimental, and this syntax might change or be removed later.\n\n### Synchronous Validation\n\nYou may optionally supply a validation function, which is in the form `({}) => {}` and takes in all\nyour data and spits out error messages. Your error messages may be strings or arrays of strings (if your field data \nis complex). For example:\n\n```javascript\nfunction validateContact(data) {\n  const errors = {};\n  if(!data.name) {\n    errors.name = 'Required';\n  }\n  if(data.address && data.address.length > 50) {\n    errors.address = 'Must be fewer than 50 characters';\n  }\n  if(!data.phone) {\n    errors.phone = 'Required';\n  } else if(!/\\d{3}-\\d{3}-\\d{4}/.test(data.phone)) {\n    errors.phone = 'Phone must match the form \"999-999-9999\"'\n  }\n  return errors;\n}\n```\nYou get the idea.\n\n### Asynchronous Validation\n\nAsync validation can be achieved by calling an additional function on the function returned by\n`connectReduxForm()` and passing it an asynchronous function that returns a promise that will resolve\nto validation errors of the format that the synchronous [validation function](#synchronous-validation)\ngenerates. So this...\n\n```javascript\n// apply connectReduxForm() and include synchronous validation\nContactForm = connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact\n})(ContactForm);\n```\n...changes to this:\n```javascript\nfunction validateContactAsync(data) {\n  return new Promise((resolve, reject) => {\n    const errors = {};\n    // do async validation\n    resolve(errors);\n  });\n}\n\n// apply connectReduxForm() and include synchronous AND asynchronous validation\nContactForm = connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact,\n  asyncValidate: validateContactAsync\n})(ContactForm);\n```\n\nOptionally, if you want asynchronous validation to be triggered when one or more of your form\nfields is blurred, you may pass those fields to the `async()` function along with the asynchronous\nvalidation function. Like so:\n\n```javascript\n// will only run async validation when 'name' or 'phone' is blurred\nContactForm = connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact,\n  asyncValidate: validateContactAsync,\n  asyncBlurFields: ['name', 'phone']\n})(ContactForm);\n```\nWith that call, the asynchronous validation will be called when either `name` or `phone` is blurred.\n*Assuming that they have their `onBlur={handleBlur('name')}` properties properly set up.*\n\n**NOTE!** If you _only_ want asynchronous validation, you may leave out the synchronous validation function.\nAnd if you only want it to be run on submit, you may leave out the async blur fields, as well.\n```javascript\nContactForm = connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  asyncValidate: validateContactAsync\n})(ContactForm);\n```\n\n### Submitting Your Form\n\nThe recommended way to submit your form is to create your form component as [shown above](#how-it-works),\nusing the `handleSubmit` prop, and then pass an [`onSubmit` prop](#onsubmit-function-optional) to your form component.\n\n```javascript\nimport React, {Component, PropTypes} from 'react';\nimport {connect} from 'react-redux';\nimport {initialize} from 'redux-form';\n\nclass ContactPage extends Component {\n  static propTypes = {\n    dispatch: PropTypes.func.isRequired\n  }\n  \n  handleSubmit(data) {\n    console.log('Submission received!', data);\n    this.props.dispatch(initialize('contact', {})); // clear form\n  }\n  \n  render() {\n    return (\n      <div>\n        <h1>Contact Information</h1>\n        \n        <ContactForm onSubmit={this.handleSubmit.bind(this)}/>\n      </div>\n    );\n  }\n}\n\nexport default connect()(ContactPage);  // adds dispatch prop\n```\n\nOr, if you wish to do your submission directly from your decorated form component, you may pass a function\nto `handleSubmit`. To abbreviate the example [shown above](#how-it-works):\n\n```javascript\nclass ContactForm extends Component {\n  static propTypes = {\n    // ...\n    handleSubmit: PropTypes.func.isRequired\n  }\n  \n  saveForm(data) {\n    // make server call to save the data\n  }\n  \n  render() {\n    const {\n      // ...\n      handleSubmit\n    } = this.props;\n    return (\n      <form onSubmit={handleSubmit(this.saveForm)}> // <--- pass saveForm\n        // ...\n      </form>\n    );\n  }\n}\n```\n\n### Responding to Other Actions\n\nPart of the beauty of the flux architecture is that all the reducers (or \"stores\", in canonical Flux terminology)\nreceive all the actions, and they can modify their data based on any of them. For example, say you have a login form,\nand when your login submission fails, you want to clear out the password field. Your login submission is part of\nanother reducer/actions system, but your form can still respond.\n\nRather than just using the vanilla reducer from `redux-form`, you can augment it to do other things by calling \nthe `plugin()` function.\n\n```javascript\nimport {reducer as formReducer} from 'redux-form';\nimport {AUTH_LOGIN_FAIL} from '../actions/actionTypes';\n\nconst reducers = {\n  // ... your other reducers here ...\n  form: formReducer.plugin({\n    login: (state, action) => { // <------ 'login' is name of form given to connectReduxForm()\n      switch(action.type) {\n        case AUTH_LOGIN_FAIL:\n          return {\n            ...state,\n            password: {}        // <----- clear password field\n          };\n        default:\n          return state;\n      }\n    }\n  })\n}\nconst reducer = combineReducers(reducers);\nconst store = createStore(reducer);\n```\n\n### Normalizing Form Data\n\nLet's say that you have a form field that only accepts uppercase letters and another one where you want the value to \nbe formatted in the `999-999-9999` United States phone number format. `redux-form` gives you a way to normalize your\ndata on every action to the reducer by calling the `normalize()` function on the default reducer.\n\n```javascript\nimport {reducer as formReducer} from 'redux-form';\n\nconst reducers = {\n  // ... your other reducers here ...\n  form: formReducer.normalize({\n    contact: {                                           // <--- the form name\n      licensePlate: (value, previousValue, allValues) => // <--- field normalizer\n        value && value.toUpperCase(),\n      phone: (value, previousValue, allValues) => {      // <--- field normalizer\n        if (value) {\n          const match = value.match(/(\\d{3})-?(\\d{3})-?(\\d{4})/);\n          if (match) {\n            return `${match[1]}-${match[2]}-${match[3]}`;\n          }\n        }\n        return value;\n      }\n    }\n  })\n}\nconst reducer = combineReducers(reducers);\nconst store = createStore(reducer);\n```\n\n### Editing Multiple Records\n\nEditing multiple records on the same page is trivially easy with `redux-form`. All you have to do is to pass a\nunique `formKey` and `initialValues` props into your form element. Let's say we want to edit many contacts on the\nsame page.\n\n```javascript\nimport React, {Component, PropTypes} from 'react';\nimport ContactForm from './ContactForm';\n\nexport default class ContactsPage extends Component {\n  static propTypes = {\n    contacts: PropTypes.array.isRequired  // how you pass the data in is up to you\n  }\n  \n  handleSubmit(id, data) {\n    // send to server\n  }\n  \n  render() {\n    const {contacts} = this.props;\n    return (\n      <div>\n        {contacts.map(function (contact) {\n          return <ContactForm\n                   key={contact.id}                  // required by react\n                   formKey={String(contact.id)}      // required by redux-form\n                   initialValues={contact}           // initialize form values\n                   onSubmit={this.handleSubmit.bind(this, contact.id)}/>\n        })}\n      </div>\n    );\n  }\n}\n```\n\n### Calculating `props` from Form Data\n\nYou may want to have some calculated props, perhaps using [`reselect`](https://github.com/faassen/reselect)\nselectors based on the values of the data in your form. You might be tempted to do this in the `mapStateToProps`\ngiven to `connect()`. __This will not work__. The reason is that the form contents in the Redux store are lazily \ninitialized, so `state.form.contacts.data.name` will fail, because `state.form.contacts` will be `undefined` until the \nfirst form action is dispatched.\n\nThe recommended way to accomplish this is to use yet another Higher Order Component decorator, such as\n[`map-props`](https://github.com/erikras/map-props), like so:\n```javascript\nimport mapProps from 'map-props';\n...\n// FIRST map props\nContactForm = mapProps({\n  hasName: props => !!props.name.value\n  hasPhone: props => !!props.phone.value\n})(ContactForm);\n\n// THEN apply connectReduxForm() and include synchronous validation\nContactForm = connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact\n})(ContactForm);\n...\n```\nOr, in ES7 land...\n```javascript\n@connectReduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact\n})\n@mapProps({\n  hasName: props => !!props.name.value\n  hasPhone: props => !!props.phone.value\n})\nexport default class ContactForm extends Component {\n```\n---\n\n### Dynamic Forms\n\nWhat if you don't know the shape of your form, i.e. what fields are needed, until runtime, maybe based on some data\nretrieved from the server? No problem! Because of the functional nature of React, Redux and `redux-form`, you can\ndefine **_and decorate_** your form component at runtime.\n\n```javascript\nimport React, {Component, PropTypes} from 'react';\nimport {connectReduxForm} from 'redux-form';\n\nclass DynamicForm extends Component {\n  static propTypes = {\n    formName: PropTypes.string.isRequired,\n    fieldsNeeded: PropTypes.arrayOf(PropTypes.string).isRequired\n  }\n  \n  render() {\n    const {formName, fieldsNeeded} = this.props;\n    \n    // define form class\n    class Form extends Component {\n      static propTypes = {\n        fields: PropTypes.object.isRequired\n      }\n  \n      render() {\n        const {fields} = this.props;  // passed in by redux-form\n        return (\n          <div>\n            {Object.keys(fields).map(fieldName => <div key={fieldName}>\n              <label>{fieldName}</label>\n              <input type=\"text\" {...fields[fieldName]}/>\n            </div>)}\n          </div>\n        );\n      }\n    }\n    \n    // connect Form to Redux and decorate with redux-form\n    Form = connectReduxForm({ form: formName, fields: fieldsNeeded })(Form);\n    \n    // render connected and decorated form\n    return <Form/>;\n  }\n}\n```\n\n---\n\n## Advanced Usage\n\n#### Doing the `connect()`ing Yourself\n\nIf, for some reason, you cannot mount the `redux-form` reducer at `form` in Redux, you may mount it anywhere else and\ndo the `connect()` call yourself. Rather than wrap your form component with `redux-form`'s `connectReduxForm()`, you \nwill need to wrap your form component *both* with \n[React Redux](https://github.com/gaearon/react-redux)'s `connect()` function *and* with `redux-form`'s\n`reduxForm()` function.\n\n```javascript\nimport React, {Component, PropTypes} from 'react';\nimport {connect} from 'react-redux';\nimport reduxForm from 'redux-form';\nimport validateContact from './validateContact';\n\nclass ContactForm extends Component {\n  //...\n}\n\n// apply reduxForm() and include synchronous validation\n// note: we're using reduxForm, not connectReduxForm\nContactForm = reduxForm({\n  form: 'contact',\n  fields: ['name', 'address', 'phone'],\n  validate: validateContact\n})(ContactForm);\n\n// ------- HERE'S THE IMPORTANT BIT -------\nfunction mapStateToProps(state, ownProps) {\n  // this is React Redux API: https://github.com/rackt/react-redux\n  // for example, you may use ownProps here to refer to the props passed from parent.\n  return {\n    form: state.placeWhereYouMountedFormReducer[ownProps.something]\n  };\n}\n\n// apply connect() to bind it to Redux state\nContactForm = connect(mapStateToProps)(ContactForm);\n\n// export the wrapped component\nexport default ContactForm;\n```\n\nAs you can see, `connectReduxForm()` is a tiny wrapper over `reduxForm()` that applies `connect()` for you.\n\n##### Binding Action Creators\n\nWhen doing the `connect()`ing yourself, if your form component also needs other redux action creators - _and you will\nif you are performing your server submit in your form component_ - you cannot simply use the default\n`bindActionCreators()` from `redux`, because that will remove `dispatch` from the props the `connect()` passes \nalong, and `reduxForm()` needs `dispatch`. You will need to also include `dispatch` in your `mapDispatchToProps()`\nfunction. So change this...\n\n```javascript\nimport {bindActionCreators} from `redux`;\n\n...\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(actionCreators, dispatch);\n}\n\nContactForm = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ContactForm);\n```\n\n...to...\n\n```javascript\nimport {bindActionCreators} from `redux`;\n\n...\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    ...bindActionCreators(actionCreators, dispatch),\n    dispatch  // <----- passing dispatch, too\n  };\n}\n\nContactForm = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ContactForm);\n```\n\n---\n## API\n\n### `connectReduxForm(config:Object)`\n\n#### -`config.form : string` [optional]\n\n> the name of your form and the key to where your form's state will be mounted, under the `redux-form` reducer, in the \nRedux store. If you do not provide this, you must pass it in as a `formName` prop to your component.\n\n#### -`config.fields : Array<string>`\n\n> a list of all your fields in your form. This is used for marking all of the fields as `touched` on submit.\n\n#### -`config.validate : Function` [optional]\n\n> your [synchronous validation function](#synchronous-validation). Defaults to `() => ({})`\n\n#### -`config.readonly : boolean` [optional]\n\n> if `true`, the decorated component will not be passed any of the `handleX` or `onX` props that will allow it to\nmutate the state. Useful for decorating another component that is not your form, but that needs to know about the\nstate of your form.\n\n#### -`config.touchOnBlur : boolean` [optional]\n\n> marks fields to touched when the blur action is fired. Defaults to `true`\n\n#### -`config.touchOnChange : boolean` [optional]\n\n> marks fields to touched when the change action is fired. Defaults to `false`\n\n#### -`config.asyncValidate : Function` [optional]\n\n> a function that takes all the form data and returns a Promise that will resolve to an object\nof validation errors in the form `{ field1: <string>, field2: <string>, valid: <boolean> }` just like the\n[synchronous validation function](#synchronous-validation). See \n[Aynchronous Validation](#asynchronous-validation) for more details.\n\n#### -`config.asyncBlurFields : Array<String>` [optional]\n\n> field names for which `handleBlur` should trigger a call to the `asyncValidate` function. Defaults to `[]`.\n\n---\n  \n### `reduxForm(config:Object)`\n\n> __[NOT RECOMMENDED]__ `reduxForm()` has the same API as \n  [`connectReduxForm()`](#connectreduxformformnamestring-fieldsarrayltstringgt-validatefunction-touchonblurboolean-touchonchangeboolean)\n  except that ___you must [wrap the component in `connect()` yourself](#doing-the-connecting-yourself)___.\n  \n---\n  \n### `reducer`\n\n> The form reducer. Should be given to mounted to your Redux state at `form`.\n\n---\n  \n### `reducer.plugin(Object<String, Function>)`\n\n> Returns a form reducer that will also pass each action through additional reducers specified. The parameter should \nbe an object mapping from `formName` to a `(state, action) => nextState` reducer. **The `state` passed to each reducer \nwill only be the slice that pertains to that form.** See [Responding to Other Actions](#responding-to-other-actions).\n\n---\n  \n### `reducer.normalize(Object<String, Object<String, Function>>)`\n\n> Returns a form reducer that will also pass each form value through the normalizing functions provided. The \nparameter is an object mapping from `formName` to an object mapping from `fieldName` to a normalizer function. The \nnormalizer function is given three parameters and expected to return the normalized value of the field.\nSee [Normalizing Form Data](#normalizing-form-data).\n\n##### -`value : string`\n\n> The current value of the field\n\n##### -`previousValue : string`\n\n> The previous value of the field before the current action was dispatched\n\n##### -`allValues : Object<string, string>`\n\n> All the values of the current form\n\n---\n  \n### `props` passed into your decorated component\n\nThe props passed into your decorated component by `redux-form` will be:\n\n#### -`active : String`\n\n> the name of the currently active (with focus) field\n\n#### -`asyncValidate : Function`\n\n> a function that may be called to initiate asynchronous validation if asynchronous validation is enabled\n\n#### -`asyncValidating : boolean`\n\n> `true` if the asynchronous validation function has been called but has not yet returned.\n\n#### -`dirty : boolean`\n\n> `true` if the form data has changed from its initialized values. Opposite of `pristine`.\n\n#### -`fields : Object`\n\n> The form data, in the form `{ field1: <Object>, field2: <Object> }`, where each field `Object` has the following \nproperties:\n\n##### ---`active : boolean`\n\n> `true` if this field currently has focus. It will only work if you are passing `handleFocus` to your input element.\n\n##### ---`checked : boolean?`\n\n> An alias for `value` _only when `value` is a boolean_. Provided for convenience of destructuring the whole field\nobject into the props of a form element.\n\n##### ---`dirty : boolean`\n\n> `true` if the field value has changed from its initialized value. Opposite of `pristine`.\n\n##### ---`error : String?`\n\n> The error for this field if its value is not passing validation. Both synchronous and asynchronous validation \nerrors will be reported here.\n\n##### ---`handleBlur : Function`\n\n> A function to call when the form field loses focus. It expects to receive the \n[React SyntheticEvent](http://facebook.github.io/react/docs/events.html) and is meant to be passed to the form\nelement's `onBlur` prop. _Alternatively: you may pass the value directly into `handleBlur` to set the value on in the\nform._\n\n##### ---`handleChange : Function`\n\n> A function to call when the form field is changed. It expects to receive the \n[React SyntheticEvent](http://facebook.github.io/react/docs/events.html) and is meant to be passed to the form\nelement's `onChange` prop. _Alternatively: you may pass the value directly into `handleChange` to set the value on in\nthe form._\n\n##### ---`handleFocus : Function`\n\n> A function to call when the form field receives focus. It is meant to be passed to the form\nelement's `onFocus` prop.\n\n##### ---`invalid : boolean`\n\n> `true` if the field value fails validation (has a validation error). Opposite of `valid`.\n\n##### ---`name : String`\n\n> The name of the field. It will be the same as the key in the `fields` Object, but useful if bundling up a field to \nsend down to a specialized input component.\n\n##### ---`onBlur : Function`\n\n> An alias for `handleBlur`. Provided for convenience of destructuring the whole field object into the props of a \nform element.\n\n##### ---`onChange : Function`\n\n> An alias for `handleChange`. Provided for convenience of destructuring the whole field object into the props of a \nform element.\n\n##### ---`onFocus : Function`\n\n> An alias for `handleFocus`. Provided for convenience of destructuring the whole field object into the props of a \nform element.\n\n##### ---`pristine : boolean`\n\n> `true` if the field value is the same as its initialized value. Opposite of `dirty`.\n\n##### ---`touched : boolean`\n\n> `true` if the field has been touched.\n\n##### ---`valid : boolean`\n\n> `true` if the field value passes validation (has no validation errors). Opposite of `invalid`.\n\n##### ---`value: any`\n\n> The value of this form field. It will be a boolean for checkboxes, and a string for all other input types.\n\n##### ---`visited: boolean`\n\n> `true` if this field has ever had focus. It will only work if you are passing `handleFocus` to your input element.\n\n#### -`handleBlur(field:string, value:any?) : Function`\n\n> Returns a `handleBlur` function for the field passed. `handleBlur('age')` returns `fields.age.handleBlur`. If you \npass it both a field and a value, it will set that value in the form. If you give it just a field, it will return a \nfunction that will set the value when either given the value or an event from an input.\n\n#### -`handleChange(field:string, value:any?) : Function`\n\n> Returns a `handleChange` function for the field passed. `handleChange('age')` returns `fields.age.handleChange`. If\nyou pass it both a field and a value, it will set that value in the form. If you give it just a field, it will return a \nfunction that will set the value when either given the value or an event from an input.\n\n#### -`handleFocus(field:string) : Function`\n\n> Returns a `handleFocus` function for the field passed. `handleFocus('age')` returns `fields.age.handleFocus`, a\nfunction to be passsed to the `onFocus` prop of your input component.\n\n#### -`handleSubmit : Function`\n\n> a function meant to be passed to `<form onSubmit={handleSubmit}>` or to `<button onClick={handleSubmit}>`.\nIt will run validation, both sync and async, and, if the form is valid, it will call `this.props.onSubmit(data)`\nwith the contents of the form data.\n\n> Optionally, you may also pass your `onSubmit` function to `handleSubmit` which will take the place of the \n`onSubmit` prop. For example: `<form onSubmit={handleSubmit(this.save.bind(this))}>`\n\n> If your `onSubmit` function returns a promise, the [`submitting`](#-submitting--boolean) property will be set to\n`true` until the promise has been resolved or rejected. If it is rejected with an object matching\n`{ field1: 'error', field2: 'error' }` then the submission errors will be added to each field (to the\n[`error`](#---error--string) prop) just like async validation errors are.\n\n#### -`initializeForm(data:Object) : Function`\n\n> Initializes the form data to the given values. All `dirty` and `pristine` state will be determined by\ncomparing the current data with these initialized values.\n\n#### -`invalid : boolean`\n\n> `true` if the form has validation errors. Opposite of `valid`.\n\n#### -`pristine: boolean`\n\n> `true` if the form data is the same as its initialized values. Opposite of `dirty`.\n\n#### -`resetForm() : Function`\n\n> Resets all the values in the form to the initialized state, making it pristine again.\n\n#### -`formKey : String`\n\n> The same `formKey` prop that was passed in. See [Editing Multiple Records](#editing-multiple-records).\n\n#### -`submitting : boolean`\n\n> Whether or not your form is currently submitting. This prop will only work if you have passed an\n`onSubmit` function that returns a promise. It will be true until the promise is resolved or rejected.\n\n#### -`touch(...field:string) : Function`\n\n> Marks the given fields as \"touched\" to show errors.\n\n#### -`touchAll() : Function`\n\n> Marks all fields as \"touched\" to show errors. should be called on form submission.\n\n#### -`untouch(...field:string) : Function`\n\n> Clears the \"touched\" flag for the given fields\n\n#### -`untouchAll() : Function`\n\n> Clears the \"touched\" flag for the all fields\n\n#### -`valid : boolean`\n\n> `true` if the form passes validation (has no validation errors). Opposite of `invalid`.\n\n#### -`values : Object`\n\n> All of your values in the form `{ field1: <string>, field2: <string> }`.\n\n---\n\n### `props` you can pass into your decorated component\n\nThe props that you can pass into decorated component by `redux-form` will be:\n\n#### -`formKey : String` [optional]\n\n> a unique key for the subform this component will be editing. See\n[Editing Multiple Records](#editing-multiple-records).\n\n#### -`formName : String` [optional]\n\n> the name of your form and the key to where your form's state will be mounted, under the `redux-form` reducer, in the \nRedux store. Will overwrite any [`config.form`](#-configform--string-optional) value that was passed to \n[`connectReduxForm(config)`](#connectreduxformconfigobject).\n\n#### -`initialValues : Object` [optional]\n\n> the values with which to initialize your form in `componentWillMount`. Particularly useful when\n[Editing Multiple Records](#editing-multiple-records), but can also be used with single-record forms.\n\n#### -`onSubmit : Function` [optional]\n\n> the function to call with the form data when the `handleSubmit` is fired from within the form component. If you\ndo not specify it as a prop here, you must pass it as a parameter to `handleSubmit` inside your form component.\n\n> If your `onSubmit` function returns a promise, the [`submitting`](#-submitting--boolean) property will be set to\n`true` until the promise has been resolved or rejected. If it is rejected with an object matching\n`{ field1: 'error', field2: 'error' }` then the submission errors will be added to each field (to the\n[`error`](#---error--string) prop) just like async validation errors are.\n\n---\n\n### Action Creators\n\n`redux-form` exports all of its internal action creators, allowing you complete control to dispatch any action\nyou wish. However, **it is *highly* recommended that you use the actions passed as props to your component\nfor most of your needs.**\n\n#### -`blur(form:String, field:String, value:String)`\n\n> Saves the value and, if you have `touchOnBlur` enabled, marks the field as `touched`.\n\n#### -`change(form:String, field:String, value:String)`\n\n> Saves the value and, if you have `touchOnChange` enabled, marks the field as `touched`.\n\n#### -`initialize(form:String, data:Object)`\n\n> Sets the initial values in the form with which future data values will be compared to calculate\n`dirty` and `pristine`. The `data` parameter should only contain `String` values.\n\n#### -`initializeWithKey(form:String, formKey, data:Object)`\n\n> Used when editing multiple records with the same form component. See\n[Editing Multiple Records](#editing-multiple-records).\n\n#### -`reset(form:String)`\n\n> Resets the values in the form back to the values past in with the most recent `initialize` action.\n\n#### -`startAsyncValidation(form:String)`\n\n> Flips the `asyncValidating` flag `true`.\n\n#### -`stopAsyncValidation(form:String, errors:Object)`\n\n> Flips the `asyncValidating` flag `false` and populates `asyncErrors`.\n\n#### -`touch(form:String, ...fields:String)`\n\n> Marks all the fields passed in as `touched`.\n\n#### -`untouch(form:String, ...fields:String)`\n\n> Resets the 'touched' flag for all the fields passed in.\n\n---\n  \n## Working Demo\n\nCheck out the \n[react-redux-universal-hot-example project](https://github.com/erikras/react-redux-universal-hot-example) to see \n`redux-form` in action.\n\nThis is an extremely young library, so the API may change. Comments and feedback welcome.\n",
  "readmeFilename": "README.md",
  "_id": "redux-form@1.5.0",
  "_shasum": "3d5e6dd8954a1df4c0f241a8b1759827b96d35dc",
  "_from": "redux-form@^1.4.1",
  "_resolved": "https://registry.npmjs.org/redux-form/-/redux-form-1.5.0.tgz"
}
